# Internationalization (i18n)

## What it is
Internationalization system for serving localized content. Provides JSON bundles for different locales with admin management.

This feature can be integrated in two ways:

1. Server-side (EJS): use the `res.locals.t()` helper (recommended for SSR content).
2. Client-side (DOM injection): mark elements with dataset attributes (recommended for static markup or progressive enhancement).

## Base URL / mount prefix
When mounted at `/saas`, all routes are prefixed:
- `/saas/api/i18n/bundle`

If you mount SaasBackend under a different prefix (example `/saasbackend`), use:
- `/saasbackend/api/i18n/bundle`

The admin UI is also prefixed:
- `/saas/admin/i18n`
- `/saasbackend/admin/i18n`

## Required app configuration

### 1) Mount SaasBackend middleware
SaasBackend must be mounted so the i18n API/admin routes exist.

### 2) Enable the i18n middleware (for SSR)
To make the EJS helper available, you must also mount the i18n middleware:

- It resolves the effective locale from request (`lang` cookie, `?lang=`, `Accept-Language`).
- It exposes `res.locals.locale`, `res.locals.defaultLocale`.
- It exposes `res.locals.t(key, vars?, opts?)`.

If you skip this middleware:

- `GET /api/i18n/bundle` will still work.
- EJS pages will *not* have `t()` and you wonâ€™t be able to render translations server-side.

## API

### Public endpoints
- `GET ${BASE_URL}/api/i18n/bundle?locale=en` - Get translation bundle

Response shape:

- `locale`: effective locale
- `defaultLocale`: default locale
- `entries`: flat key/value map

## Admin UI
- `/saas/admin/i18n` - Locale and translation management

## Integration option A: EJS helper (`res.locals.t`)

Use this when you want translations rendered server-side.

Example:

- `<%= t('HERO.LIST_PROJECT_BUTTON') %>`

Interpolation variables:

- Translation values can include placeholders like `{name}`.
- Call `t('GREETING', { name: user.name })`.

Notes:

- The helper returns a *string*. If you want to render raw HTML, you must explicitly choose the unescaped EJS tag (`<%- ... %>`). (Only do this if you trust the translation content.)

## Integration option B: DOM dataset attributes (client-side injection)

Use this when you want to keep markup simple and apply translations at runtime.

1) Add dataset attributes to the element:

- `data-i18n-key="HERO.LIST_PROJECT_BUTTON"` (required)
- Optional:
  - `data-i18n-vars='{"name":"Jane"}'` (JSON string)
  - `data-i18n-attr="title,aria-label"` (apply translation to attributes instead of text)
  - `data-i18n-html` (set `innerHTML` instead of `textContent`)

2) Add a small script that:

- Loads the bundle from `GET <mountPrefix>/api/i18n/bundle?locale=...`
- Replaces content for all `[data-i18n-key]` nodes

The host app owns this script (SaasBackend only provides the bundle endpoint).

## Seeding translations (recommended)

Host apps typically keep JSON files in-repo (example `./locales/en.json`) and seed them on boot.

- Seeding is non-destructive:
  - Inserts missing keys.
  - Updates seeded keys that were never edited.
  - Never overwrites admin-edited keys.

## Common errors / troubleshooting
- **500 Internal Server Error**: Bundle generation failed or locale not found
- **404 Not Found**: Locale parameter missing or invalid

Also check:

- If mounted under a prefix, ensure your client fetches `/<prefix>/api/i18n/bundle`.
- If EJS `t` is undefined, ensure you mounted `i18n.createI18nMiddleware()` *before* your `res.render(...)` routes.
